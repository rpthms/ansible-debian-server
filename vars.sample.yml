---
# Variables needed for this playbook

#
# Following variables have been assigned some random
# values. Change them to suit your needs
#

# User info
#
# You can generate a password hash using "openssl passwd -6 -salt <some-random-salt>"
# Your email address will receive the notifications sent by Postfix, as well as emails
# from LetsEncrypt regarding your SSL certificates
#
user_name: "user"
user_password_hash: "$6$saltgoeshere$OfAtCqYPcNjH3EOBMl4RBTJxMGLvAzjUcUoLDVPE1y5uoymUPt4.coMB/BcicrT9hlviYtKbD/CiUJIHkB.HH/"
user_ssh_key: "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDFl6Awy+/8FsDX2VaMK9AahgYyjj7ooJPQel3LRtv/YhzgAijXhvQmAoJhbOHhSnuPQF8Vj/8OdIpsZjCSlliZBwGyGkKvUDK0KKlI8CYWVPRfsWcjyU9B6aLmn8l3MIhjU6Y4egP2qwED7/YOMpuHYOWvKJkpHLqP6rMw/vmTi0GmgQ6GpLkiO6PdiPGdE09yy7tR1zDMbb1qY4176zONp7AxFfC0TVYanJh+zbv6Wq3ue+xa0jEKv2+pkY14zEAbvQEAL3Sruqqqexd9oqLROGz9snrMA8f+KEbKx7DLRW0j3jG2LZzWWAGRIZVaa3VQe8piBxVGtCIEcCVbY5kT user@hostname"
user_email: "user@domain.com"

# Hostname info
#
# Your FQDN will be hostname.domain.com
#
host_name: "hostname"
host_domain: "domain.com"

# Timezone
#
# Specify the path to the time zone file under /usr/share/zoneinfo
#
time_zone_file: "Asia/Kolkata"

# SMTP info
#
# This playbook has configured Postfix to use a relay server to
# forward the emails. You'll need to specify the hostname of the
# relay server and the credentials to connect to it.
#
smtp_relay: "smtp.gmail.com:587"
smtp_user: "user@domain.com"
smtp_pass: "somerandompassword"

# Rsyslog variables
#
# If you want to remove the rsyslog package and only use systemd-journald for
# logging, set remove_rsyslog to true.
# Setting remove_rsyslog to false or not defining the variable will result in:
# - rsyslog being set as a remote syslog server, provided the rsyslog role is
#   part of your playbook
# - if the rsyslog role is not being used, then Ansible will not touch the
#   rsyslog configuration files at all.
remove_rsyslog: 'false'

# OpenVPN info
#
# openvpn_port is the port at which the OpenVPN server will be
# listening on
# openvpn_ipv4_network and openvpn_ipv6_network are the subnets
# that will be used by the server and the connecting clients.
#
openvpn_port: "1234"
openvpn_ipv4_network: "10.10.10.0/24"
openvpn_ipv6_network: "2001:db8:abcd:1234::/64"
#
# THE FOLLOWING PART IS OPTIONAL. You can delete the openvpn_ipv4_routes and
# openvpn_ipv6_routes variables if you're not going to use them.
#
# If you want the VPN users to be able to connect to the networks/LANs
# behind certain VPN clients, then add those networks to the openvpn_ipv4_network
# and openvpn_ipv6_network lists. You need to specify those routes and the common
# name of the clients through which you can reach them.
#
# OPTIONAL VARS
openvpn_ipv4_routes:
#   - ["route-network/netmask", "client-cert-common-name"]
    - ["192.168.100.0/24", "VPN-Client-1"]
openvpn_ipv6_routes:
#   - ["route-network/netmask", "client-cert-common-name"]
    - ["2001:db8:abcd:2345::/64","VPN-Client-2"]
# END OF OPTIONAL VARS

# Networking info
#
# THE FOLLOWING PART IS OPTIONAL. Add static IPv6 information here.
#
# Since you will be SSHing into your server to run this playbook,
# you already have your networking configuration in place. If you
# want to add extra static IPv6 addresses to your server's interface,
# add them to the static_ipv6 list below.
#
# OPTIONAL VARS
static_ipv6: ["2001:db8::1/64"]
# END OF OPTIONAL VARS

# nft-geo-filter info
#
# THE FOLLOWING PART IS OPTIONAL. Add the arguments to the nft-geo-filter
# script that you can find at github.com/rpthms/nft-geo-filter
#
# The arguments tell the script which countries need to be blocked from accessing
# a server. If you comment out this variable or assign an empty string to the
# variable, then nft-geo-filter won't be set on the server.
#
# OPTIONAL VARS
nft_geo_filter_args: ""
# END OF OPTIONAL VARS

# nginx
#
# Set 'nginx_private' to true if the nginx should only be accessible via a VPN
#
nginx_private: "false"

# Certbot
#
# Create a TLS certificate for a given domain
#
# This role only supports the DNS-01 method of obtaining TLS certificates. You need
# to specify certain arguments that tell certbot which DNS plugin it needs to use and
# how to use it
#
# dns_plugin: Which DNS plugin to use for the domain verification process. The "arg_name"
#             key must be one of the DNS plugin arguments that certbot accepts. The DNS
#             plugin that you choose must also be installed on the remote system, so you'll
#             also need to provide the name of the package containing your chosen DNS
#             plugin in the "package" key.
#
# dns_propagation: How long Let's Encrypt must wait to verify the TXT record set by
#                  certbot. The "arg_name" key of this hash must be the name of the
#                  "propagation-seconds" certbot argument associated with the DNS plugin
#                  in use. Specify the number of seconds to wait in the "value" key.
#
# dns_credentials: Specify the credentials certbot will use to create and destroy the
#                  TXT record. The "arg_name" key of this hash mush be the name of the
#                  "credentials" certbot argument associated with the DNS plugin in
#                  use. Store the credentials in "certbot/files/dns-creds".
#                  Each DNS plugin will have different values specified in the credential
#                  files. Check the documentation of your DNS plugin on Certbot's website.
#
certbot_dns_plugin:
  arg_name: "--dns-cloudflare"
  package: "python3-certbot-dns-cloudflare"
certbot_dns_propagation:
  arg_name: "--dns-cloudflare-propagation-seconds"
  value: "60"
certbot_dns_credentials:
  arg_name: "--dns-cloudflare-credentials"

# ZNC Bouncer
#
# The following variables set up a minimal ZNC server. Not all of the ZNC
# variables have been listed in this file. To check all the possible variables
# that can be used by the ZNC role, check roles/znc/defaults/main.yml. You can
# use any of those variables in your vars.yml file.
#
# Special cases for the modules "sasl" and "adminlog":
# - The sasl module helps you to automatically authenticate your user to the IRC
#   networks using SASL. If you want Ansible to set up SASL, you'll need to provide:
#   * The ZNC user's actual password (not the hash) in the "password" variable under
#     the user object
#   * The password used to authenticate your account to the IRC network in the
#     network_password variable under the network hash.
#
# - The adminlog module lets you log the connections made to the ZNC server. By default,
#   these logs will be stored in their own file in the ZNC user's home directory. If you
#   want those logs to go to syslog instead, the following conditions needs to be met:
#   * Set znc_send_adminlog_to_syslog to true
#   * One of the ZNC users must have "is_admin" set to true and "password" set to their
#     ZNC account's password (not the hash)
#
# Check roles/znc/defaults/main.yml to see how to specify the passwords.
#
znc_global_load_modules:
  - "webadmin"
  - "log"
  - "lastseen"

znc_listener_allow_web: 'true'

znc_users:
  # Since this user's password is not specified, the default value of 'znc-pass' will
  # be used. To use a custom password, set the password_hash and password_salt variables
  # for the user. Check roles/znc/defaults/main.yml.
  - name: 'znc_user_1'
    is_admin: 'true'
    modules:
      - "chansaver"
      - "controlpanel"

    networks:
      - name: "Freenode"
        modules:
          - "simple_away"
        servers:
          - "chat.freenode.net +6697"
          - "chat.freenode.net +7000"
          - "chat.freenode.net +7070"
        channels:
          - "#freenode"

# WireGuard
#
# Set the following variable to setup a WireGuard VPN Server
#
# wg_ipv4_address: IPv4 address for the WireGuard interface
# wg_ipv6_address: IPv6 address for the WireGuard interface
# wg_private_key: The private key used by the WireGuard VPN Server
# wg_port: The port the server should be listening on
# wg_peers: The peers for this server. Each peer should specify the public key and a comma
#           separated list of allowed IP addresses. A preshared key can also be optionally
#           specified to provide an additional layer of symmetric-key cryptography. If a
#           peer is supposed to be isolated from other peers, set "isolate" to true.
#
wg_ipv4_address: '10.10.100.1/24'
wg_ipv6_address: '2001:db8:abcd:1234::1/64'
wg_private_key: 'priv-key'
wg_port: '2345'
wg_peers:
  - wg_public_key: 'pub-key1'
    wg_preshared_key: 'preshared-key1'
    wg_allowed_ips:
      - '192.168.100.0/24'
      - '10.10.100.0/24'
  - wg_public_key: 'pub-key2'
    wg_preshared_key: 'preshared-key2'
    wg_allowed_ips:
      - '192.168.200.0/24'
    isolate: 'true'

# If you want to setup an iperf3 server to test your WireGuard VPN speeds, set
# the port which iperf3 should use in the following variable
wg_iperf3_port: '4567'

# If you have multiple servers running WireGuard and you want to connect those
# servers with WireGuard as well, fill in the following variables. Make sure all
# your WireGuard servers have each other as peers. The current setup will use a
# direct path from one the source server to the destination server. It is not going
# to route the packets via another relay WireGuard server.
wg_peer_server_ipv4_address: '10.10.200.1/24'
wg_peer_server_ipv6_address: '2001:db8:abcd:2345::1/64'
wg_peer_server_private_key: 'priv-key'
wg_peer_server_port: '2346'
wg_peer_server_peers:
  - wg_peer_hostname: 'host.domain.com'
    wg_peer_port: '3456'
    wg_peer_public_key: 'pub-key1'
    wg_peer_preshared_key: 'preshared-key1'
    wg_peer_allowed_ips:
      - '192.168.200.0/24'
      - '10.10.200.0/24'
...
